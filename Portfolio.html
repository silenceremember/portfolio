<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #222;
            font-family: monospace;
        }

        #game-container {
            width: 800px;
            height: 600px;
            border: 2px solid #444;
            position: relative;
            overflow: hidden;
            background: #1a1a1a;
        }

        #ball {
            width: 30px;
            height: 30px;
            background: #ff4444;
            border-radius: 50%;
            position: absolute;
            left: 385px;
            top: 285px;
            box-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
        }

        .platform {
            position: absolute;
            background: #444;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }

        #debug {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
<div id="game-container">
    <div id="ball"></div>
    <div id="info">
        Controls:<br>
        AD/Arrows - Push left/right<br>
        W/Up - Jump (when grounded)<br>
        S/Down - Fast fall (in air)
    </div>
    <div id="debug"></div>
</div>

<script>
    const PHYSICS = {
        GRAVITY: -9.81,               // Увеличена гравитация для более динамичного геймплея
        MASS: 2,
        LINEAR_DAMPING: 0.015,      // Уменьшено сопротивление воздуха
        GRAVITY_SCALE: 1,

        FRICTION: 0.85,             // Улучшен баланс скольжения
        BOUNCINESS: 0.65,           // Уменьшена упругость для лучшего контроля

        GROUND_HORIZONTAL_FORCE: 25, // Увеличена сила на земле
        AIR_HORIZONTAL_FORCE: 15,    // Уменьшена сила в воздухе для баланса

        JUMP_FORCE: 300,            // Увеличена сила прыжка
        FAST_FALL_FORCE: 35,        // Увеличена сила падения

        MAX_HORIZONTAL_VELOCITY: 6,  // Увеличена максимальная горизонтальная скорость
        MAX_VERTICAL_VELOCITY: 8,    // Увеличена максимальная вертикальная скорость

        RADIUS: 15,
        FIXED_TIME_STEP: 1/60
    };

    class RigidBody2D {
        constructor() {
            this.ball = document.getElementById('ball');
            this.container = document.getElementById('game-container');
            this.debug = document.getElementById('debug');

            this.position = { x: 385, y: 285 };
            this.velocity = { x: 0, y: 0 };
            this.forces = { x: 0, y: 0 };
            this.grounded = false;
            this.keys = {};

            this.WIDTH = this.container.clientWidth;
            this.HEIGHT = this.container.clientHeight;

            this.platforms = [
                { x: 0, y: this.HEIGHT - 20, width: this.WIDTH, height: 20, friction: PHYSICS.FRICTION },
                { x: 100, y: 450, width: 200, height: 20, friction: 1 },
                { x: 500, y: 350, width: 200, height: 20, friction: 1 },
                { x: 300, y: 250, width: 200, height: 20, friction: 1 }
            ];

            this.setupEventListeners();
            this.createPlatformElements();
            this.fixedUpdate();
        }

        setupEventListeners() {
            document.addEventListener('keydown', e => this.keys[e.key] = true);
            document.addEventListener('keyup', e => this.keys[e.key] = false);
        }

        createPlatformElements() {
            this.platforms.forEach(platform => {
                const element = document.createElement('div');
                element.className = 'platform';
                Object.assign(element.style, {
                    left: platform.x + 'px',
                    top: platform.y + 'px',
                    width: platform.width + 'px',
                    height: platform.height + 'px'
                });
                this.container.appendChild(element);
            });
        }

        applyForce(x, y) {
            this.forces.x += x;
            this.forces.y += y;
        }

        handleInput() {
            // Базовая гравитация всегда присутствует
            this.forces = { x: 0, y: PHYSICS.GRAVITY * PHYSICS.GRAVITY_SCALE * PHYSICS.MASS };

            // Выбираем силу в зависимости от состояния
            const horizontalForce = this.grounded ? PHYSICS.GROUND_HORIZONTAL_FORCE : PHYSICS.AIR_HORIZONTAL_FORCE;

            // Горизонтальное движение
            if (this.keys['a'] || this.keys['A'] || this.keys['ArrowLeft']) {
                this.applyForce(-horizontalForce, 0);
            }
            if (this.keys['d'] || this.keys['D'] || this.keys['ArrowRight']) {
                this.applyForce(horizontalForce, 0);
            }

            // Прыжок только когда на земле
            if (this.grounded && (this.keys['w'] || this.keys['W'] || this.keys['ArrowUp'])) {
                this.applyForce(0, PHYSICS.JUMP_FORCE);
                this.grounded = false;
            }

            // Быстрое падение только в воздухе
            if (!this.grounded && (this.keys['s'] || this.keys['S'] || this.keys['ArrowDown'])) {
                this.applyForce(0, -PHYSICS.FAST_FALL_FORCE);
            }
        }

        updatePhysics() {
            // Применяем силы
            this.velocity.x += (this.forces.x / PHYSICS.MASS) * PHYSICS.FIXED_TIME_STEP;
            this.velocity.y += (this.forces.y / PHYSICS.MASS) * PHYSICS.FIXED_TIME_STEP;

            // Воздушное сопротивление только в воздухе
            if (!this.grounded) {
                this.velocity.x *= (1 - PHYSICS.LINEAR_DAMPING * PHYSICS.FIXED_TIME_STEP);
                this.velocity.y *= (1 - PHYSICS.LINEAR_DAMPING * PHYSICS.FIXED_TIME_STEP);
            }

            // Ограничение скорости
            this.velocity.x = Math.max(-PHYSICS.MAX_HORIZONTAL_VELOCITY,
                Math.min(PHYSICS.MAX_HORIZONTAL_VELOCITY, this.velocity.x));
            this.velocity.y = Math.max(-PHYSICS.MAX_VERTICAL_VELOCITY,
                Math.min(PHYSICS.MAX_VERTICAL_VELOCITY, this.velocity.y));

            // Обновление позиции
            this.position.x += this.velocity.x;
            this.position.y -= this.velocity.y;  // Инвертированная Y для экранных координат
        }

        handleCollisions() {
            // Столкновения со стенами
            if (this.position.x < PHYSICS.RADIUS) {
                this.position.x = PHYSICS.RADIUS;
                this.velocity.x = Math.abs(this.velocity.x) * PHYSICS.BOUNCINESS;
            } else if (this.position.x > this.WIDTH - PHYSICS.RADIUS) {
                this.position.x = this.WIDTH - PHYSICS.RADIUS;
                this.velocity.x = -Math.abs(this.velocity.x) * PHYSICS.BOUNCINESS;
            }

            // Сбрасываем grounded перед проверкой платформ
            this.grounded = false;

            // Проверяем столкновения с платформами
            for (const platform of this.platforms) {
                if (this.checkCircleRectCollision(platform)) {
                    this.resolveCollision(platform);
                }
            }
        }

        checkCircleRectCollision(rect) {
            const closestX = Math.max(rect.x, Math.min(this.position.x, rect.x + rect.width));
            const closestY = Math.max(rect.y, Math.min(this.position.y, rect.y + rect.height));

            const distanceX = this.position.x - closestX;
            const distanceY = this.position.y - closestY;
            const distanceSquared = distanceX * distanceX + distanceY * distanceY;

            return distanceSquared < (PHYSICS.RADIUS * PHYSICS.RADIUS);
        }

        resolveCollision(platform) {
            const closestX = Math.max(platform.x, Math.min(this.position.x, platform.x + platform.width));
            const closestY = Math.max(platform.y, Math.min(this.position.y, platform.y + platform.height));

            const penetrationX = this.position.x - closestX;
            const penetrationY = this.position.y - closestY;
            const distance = Math.sqrt(penetrationX * penetrationX + penetrationY * penetrationY);

            if (distance === 0) return;

            const normalX = penetrationX / distance;
            const normalY = penetrationY / distance;

            const penetrationDepth = PHYSICS.RADIUS - distance;
            this.position.x += normalX * penetrationDepth;
            this.position.y += normalY * penetrationDepth;

            const isVerticalCollision = Math.abs(normalY) > Math.abs(normalX);

            if (isVerticalCollision) {
                if (normalY < 0 && this.velocity.y < 0) {
                    this.grounded = true;
                    if (Math.abs(this.velocity.y) > 2) {
                        this.velocity.y = -this.velocity.y * PHYSICS.BOUNCINESS;
                    } else {
                        this.velocity.y = 0;
                    }

                    const frictionForce = -this.velocity.x * platform.friction;
                    this.velocity.x += frictionForce * PHYSICS.FIXED_TIME_STEP;
                } else if (normalY > 0 && this.velocity.y > 0) {
                    this.velocity.y = -this.velocity.y * PHYSICS.BOUNCINESS;
                }
            } else {
                if (this.velocity.x * normalX > 0) {
                    this.velocity.x = -this.velocity.x * PHYSICS.BOUNCINESS;
                }
            }
        }

        updateDebugInfo() {
            this.debug.textContent = `
            Velocity: (${this.velocity.x.toFixed(2)}, ${this.velocity.y.toFixed(2)})
            Grounded: ${this.grounded}
            Forces: (${this.forces.x.toFixed(2)}, ${this.forces.y.toFixed(2)})
        `;
        }

        fixedUpdate = () => {
            this.handleInput();
            this.updatePhysics();
            this.handleCollisions();

            this.ball.style.left = (this.position.x - PHYSICS.RADIUS) + 'px';
            this.ball.style.top = (this.position.y - PHYSICS.RADIUS) + 'px';

            this.updateDebugInfo();
            requestAnimationFrame(this.fixedUpdate);
        }
    }

    new RigidBody2D();
</script>
</body>
</html>